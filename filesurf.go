package main

import (
    "flag"
    "path"
    "path/filepath"
    "fmt"
    "log"
    "net/http"
    "crypto/ecdsa"
    "crypto/elliptic"
    "crypto/rand"
    "crypto/x509"
    "crypto/x509/pkix"
    "encoding/pem"
    "math/big"
    "time"
    "os"
)


const DEFAULT_CERTNAME string = "filesurf.pem"
const DEFAULT_KEYNAME string = "filesurf.key"
const BUFFER_SIZE int64 = 20 << 20 // 20 MB buffer size for file upload
const DEFAULT_WEBROOT string = "www"
const DEFAULT_UPDIR string = "uploads" // TODO parameterize later

func main() {
    // Command-line flags
    port := flag.String("p", "8090", "Port to listen on.")
    baseDir := flag.String("d", DEFAULT_WEBROOT, "Base directory to serve. Will attempt creation, if it does not exist.")
    enableHTTPS := flag.Bool("s", false, "Enable HTTPS.")
    certFile := flag.String("cert", "", "Path to TLS certificate file. Necessary when not using certificate generated by filesurf.")
    keyFile := flag.String("key", "", "Path to TLS key file. Necessary when not using certificate generated by filesurf.")

    flag.Parse()

    if *port == "" {
        fmt.Fprintln(os.Stderr, "Error: -p is required, choose a valid port number.")
	flag.Usage()
        os.Exit(1)
    }

    // Give warning if baseDir is set to cwd
    ex, err := os.Executable()
    if *baseDir == "." || *baseDir == path.Dir(ex) {
        log.Printf("WARNING: Base directory set to current working directory. This might expose your TLS keys.")
    }

    // Validate base directory
    checkOrCreateDir(*baseDir)
    // Validate uploads directory
    checkOrCreateDir(DEFAULT_UPDIR)

    // Validate HTTPS options
    if *enableHTTPS {
        log.Printf("Secure mode enabled, using HTTPS.")

        if *certFile == "" && *keyFile == "" {
            log.Printf("No key or cert defined, using default self-generated.")
            *certFile = DEFAULT_CERTNAME
            *keyFile = DEFAULT_KEYNAME
            _, erri := os.Stat(*certFile)
            _, errk := os.Stat(*keyFile)

            if erri != nil || errk != nil {
                   log.Printf("Defaults not found. Generating new cert.")
                    generateKeyAndCert()
            }
        } else if *certFile == "" || *keyFile == "" {
            log.Fatal("HTTPS enabled but -cert or -key not provided")
        }
    }

    // File server with directory listing and upload endpoint
    fileServer := http.FileServer(http.Dir(*baseDir))
    http.Handle("/", fileServer)
    http.HandleFunc("/upload", fileUploadHandler )

    address := ":" + *port

    log.Printf("Serving directory: %s", *baseDir)
    log.Printf("Use endpoint /upload for uploading. POST request with form field 'content' = your data")

    if *enableHTTPS {
        log.Printf("HTTPS enabled on https://0.0.0.0%s/", address)
        err = http.ListenAndServeTLS(address, *certFile, *keyFile, nil)
    } else {
        log.Printf("HTTP enabled on http://0.0.0.0%s/", address)
        err = http.ListenAndServe(address, nil)
    }

    if err != nil {
        log.Fatalf("Server failed: %v", err)
    }

}


func generateKeyAndCert() {
    priv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
    if err != nil {
        panic(err)
    }

    notBefore := time.Now()
    notAfter := notBefore.Add(365 * 24 * time.Hour)

    serialNumber, err := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))
    if err != nil {
        panic(err)
    }

    template := x509.Certificate{
        SerialNumber: serialNumber,
        Subject: pkix.Name{
            Organization: []string{"Filesurf"},
        },
        NotBefore:             notBefore,
        NotAfter:              notAfter,
        KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
        ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
        BasicConstraintsValid: true,
    }

    derBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, &priv.PublicKey, priv)
    if err != nil {
        panic(err)
    }

    certOut, err := os.Create(DEFAULT_CERTNAME)
    if err != nil {
        panic(err)
    }
    pem.Encode(certOut, &pem.Block{Type: "CERTIFICATE", Bytes: derBytes})
    certOut.Close()

    keyOut, err := os.Create(DEFAULT_KEYNAME)
    if err != nil {
        panic(err)
    }
    pem.Encode(keyOut, pemBlockForKey(priv))
    keyOut.Close()
}


func pemBlockForKey(priv *ecdsa.PrivateKey) *pem.Block {
    b, err := x509.MarshalECPrivateKey(priv)
    if err != nil {
        panic(err)
    }
    return &pem.Block{Type: "EC PRIVATE KEY", Bytes: b}
}


func fileUploadHandler (w http.ResponseWriter, r *http.Request) {
    // Set RAM buffer size
    r.ParseMultipartForm(BUFFER_SIZE)

    // Retrieve the file from form data
    file, handler, err := r.FormFile("content")
    if err != nil {
        http.Error(w, "Error retrieving the contentfile", http.StatusBadRequest)
        return
    }
    defer file.Close()

    var sstr = prettyPrintSize(handler.Size)

    fmt.Fprintf(w, "Uploaded File: %s\n", handler.Filename)
    fmt.Fprintf(w, "File Size: %s\n", sstr)
    fmt.Fprintf(w, "MIME Header: %v\n", handler.Header)

    // Touch empty file
    dst, err := createFile(handler.Filename)
    if err != nil {
        http.Error(w, "Error saving the file", http.StatusInternalServerError)
        return
    }
    defer dst.Close()

    // Load content from uploaded form to the destination file
    if _, err := dst.ReadFrom(file); err != nil {
        http.Error(w, "Error saving the file", http.StatusInternalServerError)
    }    

    log.Printf("Received file: %s, Size: %s", handler.Filename, sstr)
}


func createFile (filename string) (*os.File, error) {

    // Build the file path and create it
    dst, err := os.Create(filepath.Join(DEFAULT_UPDIR, filename))
    if err != nil {
        return nil, err
    }

    return dst, nil
}


func prettyPrintSize (s int64) (ps string) {
    // Convert raw byte number to human readable format
    const unit = 1024
    if s < unit {
        return fmt.Sprintf("%dB", s)
    }

    div, exp := float64(unit), 0
    for n := float64(s) / unit; n >= unit; n /= unit {
        div *= unit
        exp++
    }

    return fmt.Sprintf("%.1f%cB",
        float64(s)/div,
        "KMGTPE"[exp],
    )
}


func checkOrCreateDir (filePath string) {

    info, err := os.Stat(filePath)

    if err == nil {
        // Check if path is a directory
        if !info.IsDir() {
            log.Fatalf("Error! '%s' exists, but is not a directory.", filePath)
        }

        // Check for rwx permissions
        mode := info.Mode().Perm()
        if mode&0700 != 0700 {
            log.Fatalf("Error! Insufficient permissions on '%s'.", filePath)
        }
    }

    // If path doesn't exist yet, attempt creation
    if os.IsNotExist(err) {
        if err := os.MkdirAll(filePath, 0755); err != nil {
            log.Fatalf("Failed to create directory '%s'", filePath)
        } else if err == nil {
            log.Printf("Creating directory %s", filePath)
        }
    }

}
