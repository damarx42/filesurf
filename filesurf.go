package main

import (
    "flag"
    "path"
    "path/filepath"
    "fmt"
    "log"
    "net/http"
    "crypto/ecdsa"
    "crypto/elliptic"
    "crypto/rand"
    "crypto/x509"
    "crypto/x509/pkix"
    "encoding/pem"
    "math/big"
    "time"
    "os"
)

import _ "embed"
//go:embed upload-ui.html
var uploaderHtml []byte

// ANSI coloring
const (
    cReset  = "\033[0m"
    cBold   = "\033[1m"
    cRed    = "\033[31m"
    cYellow = "\033[33m"
    cGreen  = "\033[32m"
    cBlue   = "\033[34m"
)

const DEFAULT_CERTNAME string = "filesurf.pem"
const DEFAULT_KEYNAME string = "filesurf.key"
const BUFFER_SIZE int64 = 20 << 20 // 20 MB buffer size for file upload
const DEFAULT_WEBROOT string = "www"
const DEFAULT_UPDIR string = "uploads"

// needed for password generation
const LETTERS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

// Global var to easily pass path to upload handler
// I know, passing the var by wrapper function might be nicer
var g_updir string = DEFAULT_UPDIR 


func main() {
    // Command-line flags
    port := flag.String("p", "8090", "Port to listen on.")
    baseDir := flag.String("d", DEFAULT_WEBROOT, "Base directory to serve. Will attempt creation, if it does not exist.")
    upDir := flag.String("u", DEFAULT_UPDIR, "Directory for uploads. Will attempt creation, if it does not exist.")
    enableHTTPS := flag.Bool("s", false, "Enable HTTPS.")
    certFile := flag.String("cert", "", "Path to TLS certificate file. Necessary when not using certificate generated by filesurf.")
    keyFile := flag.String("key", "", "Path to TLS key file. Necessary when not using certificate generated by filesurf.")
    basicAuth := flag.Bool("b", false , "Enable HTTP Basic Authentication.")
    basicUser := flag.String("user", "", "HTTP Basic Auth user. Generated randomly if -b is set, but parameter not defined.")
    basicPass := flag.String("pass", "", "HTTP Basic Auth password. Generated randomly if -b is set, but parameter not defined.")

    flag.Parse()
    // Set global var to argument
    g_updir = *upDir

    // Give warning if baseDir is set to cwd
    ex, err := os.Executable()
    if *baseDir == "." || *baseDir == path.Dir(ex) {
        log.Printf("%sWARNING:%s Base directory set to current working directory. This might expose your TLS keys.", cYellow, cReset)
    }

    // Give warning if upDir is set to cwd or baseDir
    if *upDir == "." || *upDir == path.Dir(ex) {
        log.Printf("%sWARNING:%s Upload directory set to current working directory. You might overwrite the binary or your TLS keys!", cYellow, cReset)
    } else if *upDir == *baseDir {
        log.Printf("%sWARNING:%s Upload directory set to same as base directory. Be careful not to overwrite existing files!", cYellow, cReset)
    }

    // Validate base directory
    checkOrCreateDir(*baseDir)
    // Validate uploads directory
    checkOrCreateDir(*upDir)

    // Validate HTTPS options
    if *enableHTTPS {
        log.Printf("Secure mode enabled, using HTTPS.")

        if *certFile == "" && *keyFile == "" {
            log.Printf("No key or cert defined, using default self-generated.")
            *certFile = DEFAULT_CERTNAME
            *keyFile = DEFAULT_KEYNAME
            _, erri := os.Stat(*certFile)
            _, errk := os.Stat(*keyFile)

            if erri != nil || errk != nil {
                   log.Printf("Defaults not found. Generating new cert.")
                    generateKeyAndCert()
            }
        } else if *certFile == "" || *keyFile == "" {
            log.Fatal("%sERROR: HTTPS enabled but -cert or -key not provided %s", cRed, cReset)
        }
    }

    // File server with directory listing and upload endpoint
    // Conditionally, apply Basic Auth middleware

    var fileServer http.Handler
    var uploadServer http.Handler
    var uiServer http.Handler

    fileServer = http.FileServer(http.Dir(*baseDir))
    uploadServer = http.HandlerFunc(fileUploadHandler)
    uiServer = http.HandlerFunc(uiUploadHandler)

    // Read / generate authentication if Basic Auth is enabled
    if *basicAuth {

        var baUser, baPass string
        var err error

        //if only one parameter set, error out
        if (*basicUser != "" && *basicPass == "") || (*basicUser == "" && *basicPass != "") {
            log.Fatalf("%sError: Both user and password must be supplied, or both ommitted to randomly generate. %s", cRed, cReset)
        } else if *basicUser != "" && *basicPass != "" {
            baUser = *basicUser
            baPass = *basicPass
        } else {
            baUser, err = randomString(12)
            if err != nil {
                log.Fatal(err)
            }

            baPass, err = randomString(12)
            if err != nil {
                log.Fatal(err)
            }
        }

        // Call Basic Auth wrapper factory to register user and password
        auth := basicAuthMiddleware(baUser, baPass)

        log.Printf("Generated Basic Authentication credentials:%s %s:%s %s", cBold, baUser, baPass, cReset)

        if !*enableHTTPS {
            log.Printf("%sWARNING:%s Using Basic Authentication but without HTTPS. Your credentials are transmitted in clear text.", cYellow, cReset)
        }

        fileServer = auth(fileServer)
        uploadServer = auth(uploadServer)
        uiServer = auth(uiServer)
    }

    http.Handle("/", fileServer)
    http.Handle("/upload", uploadServer)
    http.Handle("/upload-ui", uiServer)

    address := ":" + *port

    // Setup complete, give usage info an run server
    log.Printf("Serving directory:%s %s %s", cBold, *baseDir, cReset)
    log.Printf("Use API endpoint %s/upload%s for uploading. POST request with form field 'content' = your data", cBold, cReset)
    log.Printf("Alternatively, use %s/upload-ui%s for simple browser UI", cBold, cReset)

    if *enableHTTPS {
        log.Printf("HTTPS enabled on %shttps://0.0.0.0%s/ %s", cBold, address, cReset)
        err = http.ListenAndServeTLS(address, *certFile, *keyFile, nil)
    } else {
        log.Printf("HTTP enabled on %shttp://0.0.0.0%s/ %s", cBold, address, cReset)
        err = http.ListenAndServe(address, nil)
    }

    if err != nil {
        log.Fatalf("%sServer failed: %v %s", cRed, err, cReset)
    }

}


func generateKeyAndCert() {
    priv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
    if err != nil {
        panic(err)
    }

    notBefore := time.Now()
    notAfter := notBefore.Add(365 * 24 * time.Hour)

    serialNumber, err := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))
    if err != nil {
        panic(err)
    }

    template := x509.Certificate{
        SerialNumber: serialNumber,
        Subject: pkix.Name{
            Organization: []string{"Filesurf"},
        },
        NotBefore:             notBefore,
        NotAfter:              notAfter,
        KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
        ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
        BasicConstraintsValid: true,
    }

    derBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, &priv.PublicKey, priv)
    if err != nil {
        panic(err)
    }

    certOut, err := os.Create(DEFAULT_CERTNAME)
    if err != nil {
        panic(err)
    }
    pem.Encode(certOut, &pem.Block{Type: "CERTIFICATE", Bytes: derBytes})
    certOut.Close()

    keyOut, err := os.Create(DEFAULT_KEYNAME)
    if err != nil {
        panic(err)
    }
    pem.Encode(keyOut, pemBlockForKey(priv))
    keyOut.Close()
}


func pemBlockForKey(priv *ecdsa.PrivateKey) *pem.Block {
    b, err := x509.MarshalECPrivateKey(priv)
    if err != nil {
        panic(err)
    }
    return &pem.Block{Type: "EC PRIVATE KEY", Bytes: b}
}


func fileUploadHandler (w http.ResponseWriter, r *http.Request) {
    // Set RAM buffer size
    r.ParseMultipartForm(BUFFER_SIZE)

    // Retrieve the file from form data
    file, handler, err := r.FormFile("content")
    if err != nil {
        http.Error(w, "Error retrieving the contentfile", http.StatusBadRequest)
        return
    }
    defer file.Close()

    var sstr = prettyPrintSize(handler.Size)

    fmt.Fprintf(w, "Uploaded File: %s\n", handler.Filename)
    fmt.Fprintf(w, "File Size: %s\n", sstr)
    fmt.Fprintf(w, "MIME Header: %v\n", handler.Header)

    // Touch empty file
    dst, err := createFile(handler.Filename)
    if err != nil {
        http.Error(w, "Error saving the file", http.StatusInternalServerError)
        return
    }
    defer dst.Close()

    // Load content from uploaded form to the destination file
    if _, err := dst.ReadFrom(file); err != nil {
        http.Error(w, "Error saving the file", http.StatusInternalServerError)
    }    

    log.Printf("Received file: %s, Size: %s", handler.Filename, sstr)
}


func uiUploadHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodGet {
        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
        return
    }

    w.Header().Set("Content-Type", "text/html; charset=utf-8")
    w.WriteHeader(http.StatusOK)
    _, _ = w.Write(uploaderHtml)

}


func createFile (filename string) (*os.File, error) {

    // Build the file path and create it
    dst, err := os.Create(filepath.Join(g_updir, filename))
    if err != nil {
        return nil, err
    }

    return dst, nil
}


func prettyPrintSize (s int64) (ps string) {
    // Convert raw byte number to human readable format
    const unit = 1024
    if s < unit {
        return fmt.Sprintf("%dB", s)
    }

    div, exp := float64(unit), 0
    for n := float64(s) / unit; n >= unit; n /= unit {
        div *= unit
        exp++
    }

    return fmt.Sprintf("%.1f%cB",
        float64(s)/div,
        "KMGTPE"[exp],
    )
}


func checkOrCreateDir (filePath string) {

    info, err := os.Stat(filePath)

    if err == nil {
        // Check if path is a directory
        if !info.IsDir() {
            log.Fatalf("%sERROR:%s '%s' exists, but is not a directory.", cRed, cReset, filePath)
        }

        // Check for rwx permissions
        mode := info.Mode().Perm()
        if mode&0700 != 0700 {
            log.Fatalf("%sERROR:%s Insufficient permissions on '%s'.", cRed, cReset, filePath)
        }
    }

    // If path doesn't exist yet, attempt creation
    if os.IsNotExist(err) {
        if err := os.MkdirAll(filePath, 0755); err != nil {
            log.Fatalf("%sERROR:%s Failed to create directory '%s'", cRed, cReset, filePath)
        } else if err == nil {
            log.Printf("Creating directory %s", filePath)
        }
    }

}


func basicAuthMiddleware(username, password string) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            user, pass, ok := r.BasicAuth()
	        if !ok || user != username || pass != password {
                    w.Header().Set("WWW-Authenticate", `Basic realm="restricted"`)
                    http.Error(w, "Unauthorized", http.StatusUnauthorized)
                    return
            }
        next.ServeHTTP(w, r)
        })
    }
}


func randomString(n int) (string, error) {
    b := make([]byte, n)

    if _, err := rand.Read(b); err != nil {
        return "", err
    }

    for i := range b {
        b[i] = LETTERS[b[i]%byte(len(LETTERS))]
    }

    return string(b), nil
}
